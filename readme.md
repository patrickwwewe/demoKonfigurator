# T√ºrkonfigurator

Ein interaktiver 3D-T√ºrkonfigurator mit React/Three.js Frontend und Node.js Backend.

## üöÄ Live Demo

[Demo ansehen](https://your-github-pages-url.github.io)

## üìã Features

- **8 verschiedene T√ºrmodelle** in 5 Kategorien (Klassik, Modern, Sicherheit, Glas, √ñko)
- **50+ Ausstattungsoptionen** mit intelligenter Kompatibilit√§tspr√ºfung
- **3D-Visualisierung** mit Three.js - interaktiv drehbar und zoombar
- **Echtzeit-Preisberechnung** mit detaillierter Kostenaufstellung
- **Intelligente Filterung** - inkompatible Optionen werden automatisch ausgeblendet
- **Responsive Design** f√ºr alle Ger√§te (Desktop, Tablet, Mobile)
- **Produktions-ready** f√ºr Server-Deployment
- **Debug-Unterst√ºtzung** mit VS Code Integration

## üèóÔ∏è T√ºrkategorien

### Klassische T√ºren
- Klassik Holzt√ºr (ab 1.200‚Ç¨)
- Landhaus Eichent√ºr (ab 1.650‚Ç¨)

### Moderne T√ºren  
- Modern Aluminium (ab 1.800‚Ç¨)
- Designer Aluminium Plus (ab 2.400‚Ç¨)

### Sicherheitst√ºren
- RC2 Sicherheitst√ºr (ab 2.500‚Ç¨)
- RC3 Panzer Sicherheitst√ºr (ab 3.200‚Ç¨)

### Spezialt√ºren
- Glas-Design T√ºr (ab 2.100‚Ç¨)
- √ñko Holzt√ºr (ab 1.350‚Ç¨)

## ‚öôÔ∏è Ausstattungsoptionen (50+ verf√ºgbar)

### üîí **Sicherheit & Zugang**
- Sicherheitsschloss (+150‚Ç¨) ‚Ä¢ Smart Lock (+300‚Ç¨) ‚Ä¢ Magnetschloss (+420‚Ç¨)
- Fingerprint-Scanner (+400‚Ç¨) ‚Ä¢ Biometric-Scanner (+650‚Ç¨) ‚Ä¢ Gesichtserkennung (+750‚Ç¨)
- Keypad-Zugang (+320‚Ç¨) ‚Ä¢ RFID-Zugang (+280‚Ç¨) ‚Ä¢ App-Steuerung (+200‚Ç¨)
- Panikraum-Schloss (+890‚Ç¨) ‚Ä¢ Mehrfachverriegelung (+320‚Ç¨)

### ü™ü **Glas & Optik** 
- Glaselement (+200‚Ç¨) ‚Ä¢ Sicherheitsglas (+280‚Ç¨) ‚Ä¢ Kugelsicheres Glas (+1200‚Ç¨)
- Smart-Glas (+890‚Ç¨) ‚Ä¢ Dekoratives Glas (+350‚Ç¨) ‚Ä¢ Sichtschutzglas (+180‚Ç¨)
- Mattglas (+140‚Ç¨) ‚Ä¢ Get√∂ntes Glas (+180‚Ç¨) ‚Ä¢ Spiegeloberfl√§che (+220‚Ç¨)
- Selbstreinigendes Glas (+290‚Ç¨) ‚Ä¢ Beheizbares Glas (+340‚Ç¨)

### üè† **Komfort & Automation**
- Video-T√ºrklingel (+380‚Ç¨) ‚Ä¢ Gegensprechanlage (+450‚Ç¨) ‚Ä¢ Automatik-√ñffner (+680‚Ç¨)
- LED-Beleuchtung (+250‚Ç¨) ‚Ä¢ Bewegungsmelder (+220‚Ç¨) ‚Ä¢ Alarmsystem (+420‚Ç¨)
- T√ºrschlie√üer (+160‚Ç¨) ‚Ä¢ Backup-Batterie (+150‚Ç¨)

### üõ†Ô∏è **Klassische Ausstattung**
- T√ºrspion (+45‚Ç¨) ‚Ä¢ T√ºrkette (+35‚Ç¨) ‚Ä¢ Briefschlitz (+75‚Ç¨) ‚Ä¢ Katzenklappe (+140‚Ç¨)
- Zylinderschloss (+120‚Ç¨) ‚Ä¢ Riegel (+140‚Ç¨) ‚Ä¢ Griff-Schloss (+95‚Ç¨)

### üå°Ô∏è **D√§mmung & Schutz**
- Extra D√§mmung (+180‚Ç¨) ‚Ä¢ Schalld√§mmung (+240‚Ç¨) ‚Ä¢ Brandschutz (+380‚Ç¨)
- Wetterdichtung (+80‚Ç¨) ‚Ä¢ Schwellendichtung (+60‚Ç¨) ‚Ä¢ UV-Schutz (+160‚Ç¨)
- Bohrschutz (+280‚Ç¨) ‚Ä¢ Verst√§rkte Scharniere (+180‚Ç¨)

## üß† Intelligente Kompatibilit√§tspr√ºfung

**Das System zeigt nur passende Optionen an - inkompatible Kombinationen werden automatisch ausgeblendet!**

### üö´ **Material-basierte Beschr√§nkungen**
- **Holz/Eiche:** ‚ùå Elektronik (LED, Biometric, Smart-Glas)  
  ‚úÖ Klassisch (T√ºrspion, Briefschlitz, Zylinderschloss)
- **Glas-Aluminium:** ‚ùå Hochsicherheit (Panikschloss, Mehrfachverriegelung)  
  ‚úÖ Smart-Features (App, Smart-Glas, Automatik)
- **Stahl/Panzerstahl:** ‚ùå √ñffnungen (Katzenklappe, L√ºftungsgitter)  
  ‚úÖ Maximale Sicherheit (Biometric, Kugelsicher, Panik)

### üéØ **Kategorie-basierte Logik**
- **Klassische T√ºren:** Moderne Technik wird ausgeblendet
- **Sicherheitst√ºren:** Dekorative Elemente nicht verf√ºgbar  
- **√ñko-T√ºren:** Milit√§rtechnik nicht kompatibel
- **Glast√ºren:** Sicherheitsschl√∂sser werden ausgeblendet

### ‚ö° **Exklusive Option-Gruppen**
Nur **eine Option** pro Gruppe w√§hlbar:
- **Glastypen:** Normal ‚Ä¢ Sicherheit ‚Ä¢ Smart ‚Ä¢ Kugelsicher ‚Ä¢ Matt ‚Ä¢ Get√∂nt
- **Zugangsysteme:** Fingerprint ‚Ä¢ Biometric ‚Ä¢ Gesichtserkennung  
- **Schl√∂sser:** Sicherheit ‚Ä¢ Smart ‚Ä¢ Magnet ‚Ä¢ Panikraum
- **T√ºrsprechanlage:** T√ºrspion ‚Ä¢ Video-Klingel ‚Ä¢ Gegensprech

### üîí **Spezielle Sicherheitsregeln**
- **Automatik-√ñffner:** Schlie√üt T√ºrkette und manuelle Riegel aus
- **Panikraum-Schloss:** Keine √ñffnungen (Katzenklappe, Briefschlitz) erlaubt
- **Kugelsicheres Glas:** Erfordert vollst√§ndige Integrit√§t (keine L√∂cher)
- **Smart-Glas:** Ersetzt andere Sichtschutz-Optionen

### ‚úÖ **Benutzerfreundlichkeit**
- **Sofortiges Feedback:** Inkompatible Optionen verschwinden automatisch
- **Keine Fehlermeldungen:** Nur g√ºltige Kombinationen werden angezeigt
- **Intelligente Vorschl√§ge:** Passende Alternativen werden hervorgehoben
- **Echtzeit-Anpassung:** Bei T√ºrwechsel werden Optionen neu gefiltert

## üõ†Ô∏è Installation & Start

### Backend starten
```bash
cd backend
npm install
node server.js
```
Backend l√§uft auf: http://localhost:3000

### Frontend starten  
```bash
cd frontend
npm install
npm run dev
```
Frontend l√§uft auf: http://localhost:5173

## üêõ Debugging

VS Code Debug-Konfiguration ist bereits eingerichtet:
1. Setzen Sie Breakpoints in `server.js`
2. Dr√ºcken Sie `F5`
3. W√§hlen Sie "Debug Backend (Node.js)"





## üìÅ Projektstruktur

```
konfigurator_zwei/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ server.js          # Express Server mit Validierung
‚îÇ   ‚îú‚îÄ‚îÄ doors.json         # T√ºrkatalog und Konfiguration
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.jsx        # Haupt-React Komponente
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DoorModel.jsx    # 3D T√ºrmodell
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ConfigPanel.jsx  # Konfigurationspanel
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.jsx
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.js
‚îî‚îÄ‚îÄ .vscode/
    ‚îî‚îÄ‚îÄ launch.json        # Debug-Konfiguration
```

## üåê API Endpunkte

- `GET /api/catalog` - Kompletter T√ºrkatalog
- `POST /api/quote` - Preisberechnung mit Validierung
- `GET /api/door/:id/options` - Verf√ºgbare Optionen f√ºr eine T√ºr

## üìä Technische Details- √úberblick
Vite startet Development-Server
React rendert die Benutzeroberfl√§che
Three.js zeigt 3D-T√ºr an
Express/Node.js liefert T√ºr-Daten via API
JSON-Validierung pr√ºft Kompatibilit√§t
CORS verbindet Frontend & Backend
CSS Grid/Flexbox macht es responsive
Die API ist eine Schnittstelle, die Ihr Frontend (React-App) mit dem Backend (Node.js Server) verbindet - wie ein Kellner, der Bestellungen zwischen K√ºche und Gast √ºberbringt. In Ihrem Projekt liefert die API die T√ºr-Daten, berechnet Preise und validiert Konfigurationen √ºber URLs wie /api/catalog oder /api/quote.
er Development Server ist ein lokaler Webserver (Vite auf Port 5173), der Ihre React-App w√§hrend der Entwicklung ausf√ºhrt und dabei Features wie Hot-Reload (automatische Aktualisierung bei Code-√Ñnderungen) bereitstellt. Er fungiert auch als Proxy, der API-Anfragen an Ihr Backend weiterleitet, damit Frontend und Backend reibungslos zusammenarbeiten k√∂nnen.
## Aufbau:

- **Frontend:** React 18 + Vite + Three.js
- **Backend:** Node.js + Express
- **3D-Engine:** Three.js mit @react-three/fiber
- **Validierung:** JSON-basierte Regel-Engine
- **Responsive:** CSS Grid + Flexbox
- **Browser-Support:** Moderne Browser (ES6+)
- **Performance:** Lazy Loading + Code Splitting
- @react-three/drei (^9.88.13) - Zus√§tzliche Three.js Utilities
-  CORS Support (^2.8.5)
-  JSON-basierte Validierung (in server.js und doors.json)

  




# üü¢ UNBEDENKLICH f√ºr Firmennutzung:
Alle verwendeten Technologien sind Open Source:

React - MIT License ‚úÖ
Three.js - MIT License ‚úÖ
Vite - MIT License ‚úÖ
Node.js - MIT License ‚úÖ
Express - MIT License ‚úÖ
@react-three/fiber - MIT License ‚úÖ
üìã WAS SIE BEACHTEN M√úSSEN:
‚úÖ ERLAUBT:

Kommerzielle Nutzung
Verkauf als Produkt/Service
Kundenauftr√§ge
SaaS-Anwendungen
White-Label-L√∂sungen
‚ö†Ô∏è EMPFOHLENE MASSNAHMEN:

License-Datei erstellen mit allen verwendeten Libraries
Copyright-Hinweise in der App
Eigene Nutzungsbedingungen f√ºr Kunden
Datenschutzerkl√§rung (DSGVO-konform)
üí∞ BUSINESS-MODEL Optionen:
Lizenzverkauf an T√ºrenhersteller
SaaS-L√∂sung (monatliche Geb√ºhr)
White-Label f√ºr Handwerker/H√§ndler
Individuelle Anpassungen als Service


## üìÑ Lizenz

MIT License - siehe [LICENSE](LICENSE) f√ºr Details.





## üíª Alternative Backend-Implementierung (Pascal/C#)

**Ja, die Konfigurationsdaten und Validierungslogik k√∂nnen in Pascal oder C# implementiert werden!**

### Pascal (Object Pascal/Delphi) Backend
```pascal
unit DoorConfigurator;

interface
uses
  System.SysUtils, System.Classes, System.JSON, System.Generics.Collections;

type
  TDoorMaterial = (dmWood, dmOak, dmAluminum, dmGlass, dmSteel, dmEcoWood);
  TDoorCategory = (dcClassic, dcModern, dcSecurity, dcGlass, dcEco);
  
  TDoorOption = record
    ID: string;
    Name: string;
    Price: Currency;
  end;
  
  TDoor = class
  private
    FID: string;
    FName: string;
    FBasePrice: Currency;
    FMaterial: TDoorMaterial;
    FCategory: TDoorCategory;
    FCompatibleOptions: TList<string>;
  public
    constructor Create(const AID, AName: string; APrice: Currency; 
                      AMaterial: TDoorMaterial; ACategory: TDoorCategory);
    destructor Destroy; override;
    
    function IsOptionCompatible(const OptionID: string): Boolean;
    function ToJSON: TJSONObject;
    
    property ID: string read FID;
    property Name: string read FName;
    property BasePrice: Currency read FBasePrice;
  end;

  TDoorValidator = class
  private
    FIncompatibleRules: TDictionary<string, TList<string>>;
  public
    constructor Create;
    destructor Destroy; override;
    
    function ValidateConfiguration(Door: TDoor; Options: TList<string>): Boolean;
    function GetValidationErrors(Door: TDoor; Options: TList<string>): TStringList;
  end;
```

### C# (.NET) Backend
```csharp
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using Microsoft.AspNetCore.Mvc;

namespace DoorConfigurator.Models
{
    public enum DoorMaterial
    {
        Wood, Oak, Aluminum, Glass, Steel, EcoWood
    }

    public class Door
    {
        public string Id { get; set; }
        public string Name { get; set; }
        
        [Range(0, double.MaxValue)]
        public decimal BasePrice { get; set; }
        
        public DoorMaterial Material { get; set; }
        public List<string> CompatibleOptions { get; set; } = new();
        
        public bool IsOptionCompatible(string optionId)
        {
            return CompatibleOptions.Contains(optionId);
        }
    }

    public class ConfigurationValidator
    {
        private readonly Dictionary<string, List<string>> _incompatibleRules;
        
        public ConfigurationValidator()
        {
            _incompatibleRules = new Dictionary<string, List<string>>
            {
                ["Wood"] = new() { "led-lighting", "smart-lock" },
                ["Glass"] = new() { "security-lock", "panic-room-lock" }
            };
        }
        
        public ValidationResult ValidateConfiguration(Door door, List<string> options)
        {
            var errors = new List<string>();
            
            foreach (var option in options)
            {
                if (!door.IsOptionCompatible(option))
                {
                    errors.Add($"Option '{option}' nicht verf√ºgbar f√ºr {door.Name}");
                }
            }
            
            return new ValidationResult { IsValid = !errors.Any(), Errors = errors };
        }
    }

    [ApiController]
    [Route("api/[controller]")]
    public class DoorController : ControllerBase
    {
        [HttpPost("quote")]
        public IActionResult CalculateQuote([FromBody] QuoteRequest request)
        {
            // Validierung und Preisberechnung
            return Ok(new { Total = calculatedPrice });
        }
    }
}
```

### Warum JavaScript/Node.js f√ºr GitHub ideal ist:
- ‚úÖ **Serverless Deployment** √ºber GitHub Pages
- ‚úÖ **Keine Server-Kosten** 
- ‚úÖ **GitHub Actions** CI/CD Integration
- ‚úÖ **Frontend + Backend** in einer Sprache
- ‚ùå **Pascal/C#** ben√∂tigen dedizierten Server mit Runtime

**F√ºr lokale Entwicklung oder eigene Server sind Pascal/C# perfekt geeignet!**

## üîó Integration mit Pascal/C# Backend

### Komplette Backend-Ersetzung mit eigener Logik

#### Pascal/Delphi Server Implementation
```pascal
program DoorConfiguratorServer;

{$APPTYPE CONSOLE}

uses
  IdHTTPServer, IdContext, IdCustomHTTPServer, IdHTTPHeaderInfo,
  System.JSON, System.SysUtils, System.Generics.Collections,
  FireDAC.Comp.Client, FireDAC.Stan.Def, FireDAC.Phys.SQLite;

type
  // Datenstrukturen
  TDoorMaterial = (dmWood, dmOak, dmAluminium, dmSteel, dmGlass, dmEco);
  TDoorCategory = (dcClassic, dcModern, dcSecurity, dcGlass, dcEco);
  
  TDoorOption = record
    ID: string;
    Name: string;
    Price: Currency;
    Category: string;
  end;
  
  TDoor = class
  private
    FID: string;
    FName: string;
    FBasePrice: Currency;
    FMaterial: TDoorMaterial;
    FCategory: TDoorCategory;
    FCompatibleOptions: TArray<string>;
    FDescription: string;
    FWidth, FHeight: Integer;
  public
    constructor Create(const AID, AName: string; APrice: Currency);
    function ToJSON: TJSONObject;
    function IsOptionCompatible(const OptionID: string): Boolean;
    
    property ID: string read FID;
    property Name: string read FName;
    property BasePrice: Currency read FBasePrice;
    property Material: TDoorMaterial read FMaterial write FMaterial;
    property Category: TDoorCategory read FCategory write FCategory;
    property CompatibleOptions: TArray<string> read FCompatibleOptions write FCompatibleOptions;
  end;

  // Validierungslogik
  TConfigurationValidator = class
  private
    FIncompatibleRules: TDictionary<string, TStringList>;
    FMaterialRules: TDictionary<TDoorMaterial, TStringList>;
    FCategoryRules: TDictionary<TDoorCategory, TStringList>;
    FConflictGroups: TArray<TStringList>; // Gegenseitig ausschlie√üende Optionen
  public
    constructor Create;
    destructor Destroy; override;
    
    function ValidateConfiguration(Door: TDoor; Options: TArray<string>): TValidationResult;
    procedure LoadValidationRules; // Aus Datenbank/Config
  end;

  // REST API Handler
  TDoorConfiguratorHandler = class
  private
    FDatabase: TFDConnection;
    FValidator: TConfigurationValidator;
    FDoors: TObjectList<TDoor>;
    FOptions: TDictionary<string, TDoorOption>;
  public
    constructor Create;
    destructor Destroy; override;
    
    // API Endpunkte
    procedure HandleCatalogRequest(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
    procedure HandleQuoteRequest(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
    procedure HandleOptionsRequest(AContext: TIdContext; ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
    
    // Datenbank-Integration
    procedure LoadDoorsFromDatabase;
    procedure LoadOptionsFromDatabase;
    procedure SaveConfiguration(const DoorID: string; Options: TArray<string>; TotalPrice: Currency);
  end;

// Hauptserver
procedure StartServer;
var
  Server: TIdHTTPServer;
  Handler: TDoorConfiguratorHandler;
begin
  Handler := TDoorConfiguratorHandler.Create;
  Server := TIdHTTPServer.Create(nil);
  try
    Server.DefaultPort := 3000;
    Server.OnCommandGet := Handler.HandleCatalogRequest;
    Server.OnCommandPost := Handler.HandleQuoteRequest;
    Server.Active := True;
    
    WriteLn('Pascal T√ºrkonfigurator Server l√§uft auf Port 3000');
    WriteLn('API verf√ºgbar unter:');
    WriteLn('  GET  http://localhost:3000/api/catalog');
    WriteLn('  POST http://localhost:3000/api/quote');
    WriteLn('  GET  http://localhost:3000/api/door/{id}/options');
    
    ReadLn; // Server l√§uft bis Enter gedr√ºckt wird
  finally
    Server.Free;
    Handler.Free;
  end;
end;

begin
  StartServer;
end.
```

#### C# ASP.NET Core API
```csharp
// Program.cs
using DoorConfigurator.Models;
using DoorConfigurator.Services;
using Microsoft.EntityFrameworkCore;

var builder = WebApplication.CreateBuilder(args);

// Services
builder.Services.AddDbContext<DoorConfiguratorContext>(options =>
    options.UseSqlite("Data Source=doors.db"));
builder.Services.AddScoped<IDoorService, DoorService>();
builder.Services.AddScoped<IValidationService, ValidationService>();
builder.Services.AddScoped<IPricingService, PricingService>();

builder.Services.AddControllers();
builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(policy =>
    {
        policy.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader();
    });
});

var app = builder.Build();

app.UseCors();
app.MapControllers();
app.Run("http://localhost:3000");

// Models/Door.cs
namespace DoorConfigurator.Models
{
    public enum DoorMaterial
    {
        Wood, Oak, Aluminium, Steel, Glass, Eco
    }
    
    public enum DoorCategory  
    {
        Classic, Modern, Security, Glass, Eco
    }

    public class Door
    {
        public string Id { get; set; }
        public string Name { get; set; }
        public decimal BasePrice { get; set; }
        public DoorMaterial Material { get; set; }
        public DoorCategory Category { get; set; }
        public List<string> CompatibleOptions { get; set; } = new();
        public string Description { get; set; }
        public int Width { get; set; }
        public int Height { get; set; }
        
        public bool IsOptionCompatible(string optionId)
        {
            return CompatibleOptions.Contains(optionId);
        }
    }

    public class DoorOption
    {
        public string Id { get; set; }
        public string Name { get; set; }
        public decimal Price { get; set; }
        public string Category { get; set; }
        public List<string> IncompatibleWith { get; set; } = new();
    }

    public class ValidationRule
    {
        public string Id { get; set; }
        public DoorMaterial? MaterialRestriction { get; set; }
        public DoorCategory? CategoryRestriction { get; set; }
        public List<string> BlockedOptions { get; set; } = new();
        public List<List<string>> ConflictGroups { get; set; } = new();
        public string Reason { get; set; }
    }
}

// Services/ValidationService.cs
namespace DoorConfigurator.Services
{
    public class ValidationService : IValidationService
    {
        private readonly DoorConfiguratorContext _context;
        private readonly List<ValidationRule> _rules;
        
        public ValidationService(DoorConfiguratorContext context)
        {
            _context = context;
            LoadValidationRules();
        }
        
        public ValidationResult ValidateConfiguration(Door door, List<string> options)
        {
            var errors = new List<string>();
            
            // 1. Material-basierte Validierung
            var materialRules = _rules.Where(r => r.MaterialRestriction == door.Material);
            foreach (var rule in materialRules)
            {
                var conflicts = rule.BlockedOptions.Intersect(options).ToList();
                if (conflicts.Any())
                {
                    errors.Add($"{rule.Reason}: {string.Join(", ", conflicts)}");
                }
            }
            
            // 2. Kategorie-basierte Validierung  
            var categoryRules = _rules.Where(r => r.CategoryRestriction == door.Category);
            foreach (var rule in categoryRules)
            {
                var conflicts = rule.BlockedOptions.Intersect(options).ToList();
                if (conflicts.Any())
                {
                    errors.Add($"{rule.Reason}: {string.Join(", ", conflicts)}");
                }
            }
            
            // 3. Gegenseitig ausschlie√üende Optionen
            foreach (var rule in _rules)
            {
                foreach (var conflictGroup in rule.ConflictGroups)
                {
                    var selectedConflicts = conflictGroup.Intersect(options).ToList();
                    if (selectedConflicts.Count > 1)
                    {
                        errors.Add($"Nur eine Option erlaubt: {string.Join(" oder ", selectedConflicts)}");
                    }
                }
            }
            
            // 4. Kompatibilit√§tspr√ºfung mit T√ºr
            foreach (var option in options)
            {
                if (!door.IsOptionCompatible(option))
                {
                    errors.Add($"Option '{option}' nicht verf√ºgbar f√ºr {door.Name}");
                }
            }
            
            return new ValidationResult
            {
                IsValid = !errors.Any(),
                Errors = errors
            };
        }
    }
}

// Controllers/DoorController.cs
[ApiController]
[Route("api")]
public class DoorController : ControllerBase
{
    private readonly IDoorService _doorService;
    private readonly IValidationService _validationService;
    private readonly IPricingService _pricingService;
    
    public DoorController(IDoorService doorService, IValidationService validationService, IPricingService pricingService)
    {
        _doorService = doorService;
        _validationService = validationService;
        _pricingService = pricingService;
    }
    
    [HttpGet("catalog")]
    public async Task<IActionResult> GetCatalog()
    {
        var doors = await _doorService.GetAllDoorsAsync();
        var options = await _doorService.GetAllOptionsAsync();
        
        return Ok(new 
        { 
            doors = doors.Select(d => new
            {
                d.Id, d.Name, d.BasePrice, d.Material, d.Category,
                d.Description, d.Width, d.Height, d.CompatibleOptions
            }),
            optionPrices = options.ToDictionary(o => o.Id, o => o.Price),
            categories = Enum.GetNames<DoorCategory>().ToDictionary(c => c, c => c)
        });
    }
    
    [HttpPost("quote")]
    public async Task<IActionResult> CalculateQuote([FromBody] QuoteRequest request)
    {
        var door = await _doorService.GetDoorByIdAsync(request.DoorId);
        if (door == null)
            return BadRequest(new { error = "Ung√ºltige T√ºr-ID" });
            
        var validation = _validationService.ValidateConfiguration(door, request.Options);
        if (!validation.IsValid)
            return BadRequest(new { error = "Ung√ºltige Konfiguration", details = validation.Errors });
            
        var pricing = await _pricingService.CalculatePriceAsync(door, request.Options);
        
        // Konfiguration in Datenbank speichern f√ºr Analytics
        await _doorService.SaveConfigurationAsync(request.DoorId, request.Options, pricing.Total);
        
        return Ok(new 
        { 
            total = pricing.Total,
            basePrice = door.BasePrice,
            appliedOptions = pricing.AppliedOptions,
            door = new { door.Id, door.Name, door.Material, door.Category }
        });
    }
    
    [HttpGet("door/{doorId}/options")]
    public async Task<IActionResult> GetAvailableOptions(string doorId)
    {
        var door = await _doorService.GetDoorByIdAsync(doorId);
        if (door == null)
            return BadRequest(new { error = "Ung√ºltige T√ºr-ID" });
            
        var availableOptions = await _doorService.GetCompatibleOptionsAsync(doorId);
        
        return Ok(new
        {
            door = new { door.Id, door.Name, door.Category },
            availableOptions = availableOptions.Select(o => new { o.Id, o.Name, o.Price })
        });
    }
}
```

### Frontend-Integration mit eigenem Backend

#### JavaScript Frontend anpassen f√ºr eigene API
```javascript
// frontend/src/config/api.js
const API_CONFIG = {
  // F√ºr lokale Entwicklung mit Pascal/C# Backend
  BASE_URL: process.env.NODE_ENV === 'production' 
    ? 'https://ihre-domain.com/api'  // Ihr eigener Server
    : 'http://localhost:3000/api',   // Lokale Entwicklung
    
  ENDPOINTS: {
    CATALOG: '/catalog',
    QUOTE: '/quote',
    OPTIONS: '/door/:doorId/options'
  }
};

// API Service mit Backend-Integration
class DoorConfiguratorAPI {
  static async getCatalog() {
    try {
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.CATALOG}`);
      if (!response.ok) throw new Error('Failed to fetch catalog');
      return await response.json();
    } catch (error) {
      console.error('API Error:', error);
      // Fallback auf lokale Demo-Daten
      return this.getDemoData();
    }
  }
  
  static async calculateQuote(doorId, options) {
    try {
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.QUOTE}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ doorId, options })
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.details?.join(', ') || 'Validation failed');
      }
      
      return await response.json();
    } catch (error) {
      console.error('Quote calculation failed:', error);
      throw error;
    }
  }
  
  static async getAvailableOptions(doorId) {
    const url = API_CONFIG.BASE_URL + API_CONFIG.ENDPOINTS.OPTIONS.replace(':doorId', doorId);
    const response = await fetch(url);
    return await response.json();
  }
}

// In App.jsx verwenden
useEffect(() => {
  DoorConfiguratorAPI.getCatalog()
    .then(data => {
      setCatalog(data);
      setSelectedDoor(data.doors[0]);
      setLoading(false);
    })
    .catch(err => {
      console.error('Failed to load catalog:', err);
      setLoading(false);
    });
}, []);
```

### Datenbank-Schema f√ºr Pascal/C#

```sql
-- SQLite/PostgreSQL/SQL Server Schema
CREATE TABLE doors (
    id VARCHAR(50) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    base_price DECIMAL(10,2) NOT NULL,
    material VARCHAR(20) NOT NULL,
    category VARCHAR(20) NOT NULL,
    description TEXT,
    width INTEGER,
    height INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE door_options (
    id VARCHAR(50) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    category VARCHAR(50),
    description TEXT
);

CREATE TABLE door_compatible_options (
    door_id VARCHAR(50) REFERENCES doors(id),
    option_id VARCHAR(50) REFERENCES door_options(id),
    PRIMARY KEY (door_id, option_id)
);

CREATE TABLE validation_rules (
    id SERIAL PRIMARY KEY,
    rule_type VARCHAR(20), -- 'material', 'category', 'conflict'
    material VARCHAR(20),
    category VARCHAR(20),
    blocked_options JSON, -- Array von Option-IDs
    conflict_groups JSON, -- Array von Arrays f√ºr gegenseitig ausschlie√üende Optionen
    reason TEXT,
    active BOOLEAN DEFAULT true
);

CREATE TABLE configurations (
    id SERIAL PRIMARY KEY,
    door_id VARCHAR(50) REFERENCES doors(id),
    selected_options JSON,
    total_price DECIMAL(10,2),
    client_ip VARCHAR(45),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Beispieldaten einf√ºgen
INSERT INTO doors VALUES 
('classic-wood-001', 'Klassik Holzt√ºr', 1200.00, 'Wood', 'Classic', 'Traditionelle Holzt√ºr', 90, 210),
('modern-alu-001', 'Modern Aluminium', 1800.00, 'Aluminium', 'Modern', 'Schlankes Design', 100, 220),
('security-steel-001', 'Sicherheitst√ºr RC2', 2500.00, 'Steel', 'Security', 'Einbruchschutz RC2', 90, 210);

INSERT INTO door_options VALUES
('smart-lock', 'Smart Lock', 300.00, 'Security', 'Elektronisches Schloss'),
('glass-panel', 'Glaselement', 200.00, 'Design', 'Dekoratives Glaselement'),
('led-lighting', 'LED-Beleuchtung', 250.00, 'Comfort', 'Integrierte LED-Beleuchtung');
```

### Deployment auf eigenem Server

```bash
# Pascal/Delphi Deployment
# Kompilieren und auf Server kopieren
dcc64 DoorConfiguratorServer.dpr
scp DoorConfiguratorServer root@ihr-server.com:/opt/door-configurator/
scp doors.db root@ihr-server.com:/opt/door-configurator/

# C# Deployment
dotnet publish -c Release -o ./publish
scp -r ./publish/* root@ihr-server.com:/opt/door-configurator/

# Systemd Service (Linux)
sudo tee /etc/systemd/system/door-configurator.service > /dev/null <<EOF
[Unit]
Description=Door Configurator API
After=network.target

[Service]
Type=simple
User=www-data
WorkingDirectory=/opt/door-configurator
ExecStart=/opt/door-configurator/DoorConfiguratorServer
Restart=always

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl enable door-configurator
sudo systemctl start door-configurator
```

Mit dieser Integration l√§uft Ihr **komplettes Backend in Pascal/C#** w√§hrend das Frontend weiterhin in React bleibt!

## üéØ Geplante Features

- [ ] **Erweiterte 3D-Modelle:** Upload echter GLB/GLTF T√ºrmodelle
- [ ] **Augmented Reality (AR):** T√ºr-Vorschau in realer Umgebung
- [ ] **PDF-Export:** Vollst√§ndige Konfiguration als Angebot
- [ ] **Admin-Interface:** T√ºrverwaltung und Preispflege
- [ ] **Multi-Sprach-Unterst√ºtzung:** Englisch, Franz√∂sisch, Italienisch
- [ ] **Erweiterte Materialien:** Mehr Holzarten und Oberfl√§chenoptionen
- [ ] **Kundenbereich:** Gespeicherte Konfigurationen und Verlauf
- [ ] **Integration:** ERP-Systeme und CRM-Anbindung

## üöÄ Deployment

### GitHub Pages (Empfohlen)
1. Fork dieses Repository
2. Aktiviere GitHub Actions in den Repository-Einstellungen
3. Push l√∂st automatisches Deployment aus
4. Verf√ºgbar unter: `https://username.github.io/repository-name`

### Eigener Server
```bash
# Backend (Node.js)
cd backend
npm install --production
node server.js

# Frontend Build
cd frontend  
npm run build
# Kopiere dist/ Ordner zu Webserver
```

### Docker Deployment
```dockerfile
# Dockerfile beispiel f√ºr eigenen Server
FROM node:18-alpine
WORKDIR /app
COPY backend/ ./backend/
COPY frontend/dist/ ./frontend/
RUN cd backend && npm install --production
EXPOSE 3000
CMD ["node", "backend/server.js"]
```

## üîß Konfiguration anpassen

### Neue T√ºren hinzuf√ºgen
```json
// In backend/doors.json
{
  "id": "neue-tuer-001",
  "name": "Meine neue T√ºr",
  "basePrice": 1500,
  "material": "Holz",
  "category": "classic",
  "compatibleOptions": ["glass-panel", "peephole"]
}
```

### Neue Optionen erstellen
```json
// Neue Option zu optionPrices hinzuf√ºgen
"meine-option": 199,

// Zu gew√ºnschten T√ºren in compatibleOptions hinzuf√ºgen
"compatibleOptions": [..., "meine-option"]
```

### Inkompatibilit√§ten definieren
```json
// Material-basierte Regel
{
  "material": "Holz", 
  "blockedOptions": ["led-lighting"],
  "reason": "LED nicht mit Holz kompatibel"
}
```

## üìä Technische Details

- **Frontend:** React 18 + Vite + Three.js
- **Backend:** Node.js + Express
- **3D-Engine:** Three.js mit @react-three/fiber
- **Validierung:** JSON-basierte Regel-Engine
- **Responsive:** CSS Grid + Flexbox
- **Browser-Support:** Moderne Browser (ES6+)
- **Performance:** Lazy Loading + Code Splitting

## üìÑ Lizenz

MIT License - siehe [LICENSE](LICENSE) f√ºr Details.

## üë• Beitragen

Pull Requests sind willkommen! F√ºr gr√∂√üere √Ñnderungen √∂ffnen Sie bitte zuerst ein Issue.

### Entwicklung
```bash
# Repository clonen
git clone https://github.com/username/konfigurator_zwei.git
cd konfigurator_zwei

# Backend starten (Terminal 1)
cd backend && npm install && node server.js

# Frontend starten (Terminal 2)  
cd frontend && npm install && npm run dev
```

## üìû Support

- **Issues:** [GitHub Issues](https://github.com/username/konfigurator_zwei/issues)
- **Dokumentation:** Diese README + Code-Kommentare
- **API-Dokumentation:** `/api/` Endpunkte im Code dokumentiert

---

**üéâ Viel Spa√ü beim Konfigurieren!** Der T√ºrkonfigurator ist bereit f√ºr den produktiven Einsatz.
